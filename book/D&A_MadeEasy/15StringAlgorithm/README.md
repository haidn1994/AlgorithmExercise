# String

여기서는 문자열 데이터를 효율적으로 저장하는 데이터 구조와 효율적으로 문자열을 다루기 위한 알고리즘을 소개한다.  

## 문자열 매칭 알고리즘

여기에서는 어떤 유형P가 다른 문자열 T(T는 text를 뜻한다.)의 부분문자열(substring)인지 검사하는 문제를 살펴볼 것이다.  
고정된 문자열 P를 가지고 검사하므로 이런 알고리즘들은 정확한 문자열 매칭 알고리즘(Exact String Matching Algorithm)이라고 불린다.  
예를 들어 주어진 문자열 T의 길이가 n이고 우리가 찾으려는 유형 P의 길이는 m이라고 하자.  
즉 T에는 0에서 n - 1까지의 글자들이 있고(T[0...n-1]P에는 0에서 m-1까지의 글자들이 있다. (P[0..m-1])  
이 알고리즘은 C++에서 strstr()로 구현되어 있다.  
이제 여러분은 다음 알고리즘들의 구현 방법을 하나씩 학습할 것이다.  

* 브루트-포스 기법
* 라빈-카프 문자열 매칭 알고리즘
* 유한 오토마타(Finite Automata) 문자열 매칭
* KMP(크누스-모리스-프랫) 알고리즘
* 보이어-무어 알고리즘
* 접미어 트리(Suffix Tree)

## 브루트-포스 기법

이 기법에서는 문자열 T의 각각의 가능한 위치에 대하여 유형 P가 일치하는지 여부를 검사한다.  
T의 길이가 n이므로 n - m + 1가지의 비교 방법이 필요하다.  
왜냐하면 유형의 길이가 m이므로 T의 마지막 m-1위치는 비교할 필요가 없기 때문이다.  
다음 알고리즘이 문자열 T에서 유형P가 처음으로 나타나는 경우를 찾는다.  


```{.c}
int BruteForceStringMatch(int T[], int n, int P[], int m)
{
	int i, j;

	for(i = 0; i <= n; i++){
		j = 0;
		while(j < m && P[j] == T[i + j])
			j++;
		if(j == m)
			return i;
	}

	return -1;
}
```

## 라빈-카프 문자열 매칭 알고리즘

이 기법에서는 T의 가능한 각 위치를 검사하는 대신 해싱 기법을 이용한다.  
P의 해싱과 T의 m개 글자에서 해싱이 같은 결과일 때만 검사한다.  


처음은 T의 첫 번째 m글자에 해시 함수를 적용하고 이 결과가 P의 해싱 결과와 같은지 비교한다.  
같지 않다면, T의 다음 글자로 이동해 m개의 글자에 대해 해시 함수를 적용한다(두 번째 글자부터 시작해서).  
만약 결과가 같다면 T의 이 m개의 글자를 P와 비교한다.  

### 해시 함수 선택하기(호너의 방법을 공부할 것!)

각 단계에서 T의 m글자에 대한 해시를 찾는 것이므로 효율적인 해시 함수가 필요하다.  
해시 함수가 각 단계에서 O(m)의 복잡도를 가진다면 전체 복잡도는 O(nm)이다. 먼저 해시 함수를 적용하고,  
그 다음 비교하므로 브루트-포스 기법보다 나쁘다.  


우리의 목적은 T의 글자에 대해 매번 복잡도가 O(1)인 해시 함수를 선택하는 것이다.  
이렇게 할 때에만 알고리즘의 전체 복잡도를 감소시킬 수 있다.  
해시 함수가 좋지 않다면(최악의 경우에), 라빈-카프 알고리즘의 복잡도는  
O((n-m+1)\*m) = O(n\*m)이다. 좋은 해시 함수를 선택한다면 라빈-카프 알고리즘의 복잡도는 O(m+n)이다.  
이제 T의 m글자에 대해 매번 복잡도가 O(1)인 해시함수를 어떻게 선택할 것인지 살펴보자.  


문자열 T에 사용된 글자들이 모두 정수라고 가정하자. 즉, (T의 모든 글자) in {0, 1, 2, ..., 9}이다.  
모든 글자가 정수이므로 m개의 연속적인 글자들의 문자열을 십진수라고 생각할 수 있다.  
예를 들어 문자열 "61815"는 숫자 61815가 되는 것이다.  
위의 가정에 의해 유형 P역시 십진수가 된다. P의 십진수 값을 p라고 하자.  
주어진 문자열 T[0...n-1]에서 t(i)가 i = 0, 1...n-m-1일 때 길이가 m인 부속 문자열 T[i...i+m-1]의 십진수 값이라고 하자.  
따라서 T[i, ... i+m-1] == P[0...m-1]일 때에만 t(i) == p가 된다.  
우리는 호너의 법칙(Horner's Rule)을 이용해서 p를 O(m)시간에 계산할 수 있다.  

> p = P[m-1] + 10(P[m-2] + 10(P[m-3] + ... + 10(P[1] + 10P[0]) ...))

위에서 가정한 코드는 다음과 같다.  

```{.c}
value = 0;
for(int i = 0; i < m-1; i++){
	value = value * 10;
	value = value + P[i];
}
```

i = 0, 1, ..., n-m-1에 대해 모든 t(i)의 값을 O(n) 시간에 계산할 수 있다.
t(0)의 값도 T[0...m-1]로부터 O(m)시간에 비슷하게 계산될 수 있다.  
나머지 값t(0), t(1), ... t(n-m-1)를 계산하여면 t(i+1)이 t(i)로부터 상수시간에 계산될 수 있다는 것을 이해해야 한다.  

> t(i+1) = 10 \* (t(i) - 10^m-1 T[i]) + T[i+m-1]

예를 들어 만약 T = "123456"이고, m = 3이라면 다음과 같다.  

> t(0) = 123, t(1) = 10\*(123 - 100\*1) + 4 = 234

* 단계별 설명
	* 첫 번째: 첫 번째 숫자를 없앤다. 123 - 100\*1 = 23
	* 두 번째: 10을 곱해서 왼쪽으로 한 자리 옮긴다. 23\*10 = 230
	* 세 번째: 마지막 숫자를 더한다. 230 + 4 = 234

이 알고리즘은 t(i)와 p의 비교에 의해 수행된다. t(i) == p이면  
i위치에서 시작하는 부분 문자열 P를 T에서 찾은 것이다.  


## 유한 오토마타 문자열 매칭

> 주의! 오토마타 개념이나 컴파일러 관련 수업을 듣거나 따로 공부를 했어야 한다!

이번에는 계산 이론(Theory of Computation, ToC)의 개념인 유한 오토마타(Finite Automata)를 사용한다.  
알고리즘을 살펴보기 전에 오토마타의 정의를 먼저 살펴보자.  

### 유한 오토마타
유한 오토마톤 F는 5-튜플(tuple) (Q, Σ, δ, q0, F)로 다음과 같은 특징을 갖는다.

* Q는 유한한 상태들의 집합
* Σ는 유한한 입력 알파벳
* δ는 주어진 형태 상태와 입력에 대해 다음 상태를 리턴하는 전이(transition)함수이다. 
* q0 ∈ Q는 시작 상태
* A ⊆ Q는 수락(accepting)상태들

### 유한 오토마타는 어떻게 동작하는가?

* 유한 오토마톤 F는 상태 q0에서 시작한다.  
* Σ로부터 한 번에 하나씩 글자를 읽어들인다.  
* F가 q상태에서 글자 a를 읽어르면, F는 δ(q, a)상태로 이동한다.  
* 맨 마지막에 상태가 A안에 있으면 F는 이제까지 읽어들인 입력 문자열을 수락했다고 말한다.  
* 입력 문자열이 수락되지 않았다면 거절된(rejected) 문자열이라고 부른다.  

...(중략)...

### 유한 오토마타를 만들 때 중요한 참고 사항들

오토마타를 만들 때, 먼저 초기 상태부터 시작해야 한다.  
유형의 k글자가 매치되었다면 FA는 k상태에 있을 것이다. 다음 글자가 유형의 글자 c와 같다면,  
k + 1를 매치한 것이고 FA는 k + 1상태에 들어가게 된다. 그 다음 글자가 패턴의 글자와 같지 않다면,  
FA는 얼마나 많은 초기 유형 글자들이 C로 끝나는 글자와 매치했는가에 따라 다시 상태 0, 1, 2, ..., 또는 k상태로 돌아간다.  

### 매칭 알고리즘
이제 매칭 알고리즘에 집중해보자.  

...(중략)...

## KMP 알고리즘

앞서와 같이 T가 검색해야 할 문자열이고 P가 매칭해야 할 유형이라고 하자.  
이 알고리즘은 크누스, 모리스, 프랫에 의해 제시되었다.  
유형을 검색하는 데 O(n)의 시간 복잡도가 걸린다. O(n) 시간 복잡도를 얻기 위해,  
유형P의 어떤 항목과 이미 비교되었던 T의 항목은 다시 비교하지 않는다.  


이 알고리즘은 일반적으로 접두어 함수나 접두어 테이블 혹은 실패 함수F라고 불리우는 테이블을 사용한다.  
먼저 이 테이블을 어떻게 채우는지 살펴보고 나서 이 테이블을 이용해서 어떻게 유형을 검색하는지 살펴볼 것이다.  
접두어 함수 F는 각 유형이 자기 자신의 이동(shift)을 어떨게 매치하는지에 대한 정보를 저장한다.  
이 정보는 유형 P의 쓸모없는 이동 방지를 위해 사용될 수 있다.  
즉 이 테이블은 문자열 T에 대해 백트래킹을 방지하기 위해 사용될 수 있다.  

## 접두어 테이블

```{.c}
int F[]; // F가 전역 배열이라고 가정한다.
void Prefix-Table(int P[], int m){
	int i = 1, j = 0, F[0] = 0;
	while(i < m){
		if(P[i] == P[j]){
			F[i] = j+1;
			i++;
			j++;
		} else if(j > 0) {
			j = F[j-1];
		} else {
			F[i] = 0;
			i++;
		}
	}
}
```

말 그대로 문자열로 접두어 테이블을 채워버리면 메모리를 제곱에 비례해서 사용하게 된다.  
참고로 KMP 알고리즘의 발상을 여기에 적용하면 더욱 빠르게 실패 함수를 만들 수 있다.  

## 매칭 알고리즘

KMP 알고리즘은 유형 P, 문자열 T, 접두어 함수 F를 입력으로 받아 T안에서 P의 매치를 찾는다.  

```{.c}
int KMP(char T[], int n, char P[], int m){
	int i = 0, j = 0;
	Prefix-Table(P, m);

	while(i < n){
		if(T[i] == P[j]){
			if(j == m-1) return i - j;
			else { i++; j++; }
		} else if(j > 0) j = F[j-1];
		  else i++;
	}

	return -1;
}
```
* 시간 복잡도: O(m + n), m은 유형의 길이이고, n은 검색할 문자열의 길이이다.  
* 공간 복잡도: O(m)  

이제 과정을 이해하기 위해 예를 살펴보자(책을 찾아보시오.) 중략...

* 참고:
	* KMP는 왼쪽에서 오른쪽으로 비교를 수행한다.
	* KMP 알고리즘은 O(m)공간과 시간 복잡도가 걸리는 전처리(접두어 함수)가 필요하다.  
	* 검색은 O(n+m)시간 복잡도가 걸린다.  

## 보이어-무어 알고리즘

KMP알고리즘과 같이 보이어-무어 알고리즘도 전처리가 필요하다.  
이는 일반적으로 최종 함수라고 부른다. 알고리즘은 패턴의 글자들을 가장 오른쪽 글자부터 왼쪽을 향해 스캔한다.  
T안에 유형 P가 있을 가능성이 있는 장소를 검사하는 동안 불일치는 다음과 같이 처리된다.  
검사하는 현재 글자가 T[i] = c라고 하고, 연관된 유형의 글자가 P[j]라고 하자.  
c가 P안에 어느 곳에서도 없다면, 유형 P를 T[i]를 완전히 벗어날 때까지 이동시킨다.  
이 기법으로 유형을 문자열에 상대적으로 이동시킬 때 발생하는 많은 무의미한 비교를 피할 수 있다.  


최종 함수는 O(m + |Σ|)시간이 걸리고 실제 검색은 O(nm)시간이 걸린다.  
그러므로 보이어-무어 알고리즘의 최악의 경우 수행 시간은 O(nm + |Σ|)이다.  
이것은 최악의 경우 수행 시간이 n == m일 때 브루트-포스 알고리즘과 같은 2차 함수적임을 나타낸다.  
(문자열 검색계의 퀵소트? 같은 느낌의 검색 방법인 것 같다.)  

* 보이어-무어 알고리즘은(유형의 길이에 대해 상대적으로)큰 입력 알파벳 집합에 대해 매우 빠르다.  
* 작은 알파벳 집합에 대해서는 보이어-무어 알고리즘이 적합하지 않다.  
* 이진 문자열에 대래서는 KMP알고리즘이 추천된다.
* 매우 짧은 유형에 대해서는 브루트-포스 알고리즘이 더 나을 수도 있다.  

## 문자열 저장을 위한 데이터 구조

문자열의 집합(예를 들어 사전의 모든 단어)이 있고 이 집합에서 찾으려는 단어가 있을 때,  
이 검색 연산을 빠르게 수행하기 위해서는, 문자열을 저장하는 효율적인 방법이 필요하다.  
문자열 집합을 저장하기 위해 다음 데이터 구조 중 하나를 사용할 수 있다.  

* 해시 테이블
* 이진 검색 트리
* 트라이
* 삼진 검색 트리

## 문자열을 위한 해시 테이블

정수나 문자열을 저장하기 위해서 해시 테이블을 사용할 수 있는데,  
이 경우 키가 바로 문자열이 된다. 해시 테이블 구현의 문제점은 순서 정보를 잃는다는 것이다.  
왜냐하면 해시 함수를 적용한 뒤에 어디로 맵(map)이 될 지 모른다는 것이다. 그 결과 어떤 질의는 시간이 더 오래 걸린다.  
예를 들어 글자 "K"로 시작하는 모든 단어를 찾는다면 해시 테이블 구현에서는 전체 해시 테이블을 모두 스캔해야 한다.  
그 이유는 해시 함수가 전체 키에 대하여 해시를 수행한 각 단어의 위치를 우리가 모르기 때문이다.  

## 문자열을 위한 이진 검색 트리

이 표현에서는 각 노드가 문자열을 앞벳 순서로 정렬하기 위해 사용된다.  
문자열에는 자연스러운 순서가 있기 때문이다. A는 B보다 앞에 오고, B는 C보다 앞에 오는 등.  
단어들이 정렬될 수 있고, 이진 검색 트리, 즉 BST를 사용하여 단어들을 저장하거나 가져올 수 있다.  
예를 들어 다음의 문자열을 BST를 사용하여 저장하려 한다고 하자.  

> this is a career monk string

주어진 문자열을 BST에 표현하는 여러 방법이 있고 그 한 가지 예가 다음과 같은 트리이다.  

```{.c}
		is
	   /  \
  career  string
  /		  /		\
a		monk	this		
```

### 이진 검색 트리 표현의 문제점

이 기법은 저장 효율성 측면에서 훌륭하다. 하지만 이 표현의 단점은 각 노드에 대해  
검색 연산이 주어진 키와 노드가 완전히 일치하는지 검사를 수행하므로 그 결과 검색 연산의 시간 복잡도가 증가한다.  
그러므로 문자열의 BST표현은 저장공간을 위해서는 좋지만 시간의 측면에서는 좋지 않다고 말할 수 있다.  

## 트라이

이제 검색 연산의 시간 복잡도를 감소시킬 수 있는 다른 표현방법을 살펴보자.  
트라이(Trie)라는 이름은 re**trie**ve에서 유래했다.  

트라이는 각 노드에 알파벡 글자 수 만큼의 포인터가 있는 트리이다.  
예를 들어 모든 문자열이 영어 알파벳 "a"에서 "z"까지 이루어졌다면 트라이의 각 노드는  
26개의 포인터를 가진다. 트라이 데이터 구조는 다음과 같이 선언된다.  

### 트라이란 무엇인가?

```{.c}
struct TrieNode{
	char data; // 현재 노드의 글자
	// 루트로부터 시작해서 현재 노드까지의 문자열이 문자열인지 여부
	int isEndOfString;
	// 다른 트라이 노드를 가리키는 포인터
	struct TriNode *child[26];
};
```
### 왜 트라이를 사용하는가?
트라이는 문자열의 삽입과 검색에 O(L)시간이 걸린다(여기서 L은 한 단어의 길이)  
이는 해시 테이블이나 이진 검색 트리 표현보다 훨씬 빠르다.  

### 트라이의 선언
TrieNode의 구조체에는 data(char), isEndOfString(boolean)그리고 자식 노드의 집합(TrieNode들의 집합)이 있다.  
subNode(char)라고 불리는 메서드가 하나 더 있다. 이 메서드는 글자를 인자로 받아서 존재한다면  
그 글자의 자식 노드를 리턴한다. 트라이 데이터 구조의 기본 TrieNode항목은 다음과 같다.  


```{.c}
struct TrieNode{
	char data;
	int isEndOfString;
	struct TrieNode *child[];
}

struct TrieNode *TrieNode subNode(struct TrieNode *root, char c){
	int i ;
	if(child != NULL){
		for(i = 0; i < 26; i++){
			if(root.child[i]->data == c){
				return eachChild;
			}
		}
		return NULL;
	}
}
```

이제 TrieNode를 정의했다. 이제 트라이의 다른 연산을 살펴보자.  
다행히 트라이 데이터 구조는 두 개의 주 메서드 insert()와 search()가 있어서 구현이 간단하다.  
이 두 메서드의 기본적인 구현을 살펴보자.  

### 트라이에 문자열 삽입하기

### 트라이에서 문자열 검색하기

### 트라이 표현의 문제점들

트라이의 주 단점은. 많은 메모리르 필요로 한다는 것이다.  
위에서 보았듯이, 각 노드에는 너무 많은 노드 포인터가 있지만 많은 경우 각 노드의 점유율은 매우 낮다.  
트라이 데이터 구조에 대한 최종 결론은, 빠르지만 문자열을 저장하는데 많은 메모리를 차지한다는 것이다.  

### 압축 트라이?

트라이 압축 기법이라는 개선된 트라이 표현법이 있다. 
하지만 이 기법으로도 잎 노드의 메모리만 감소시킬 수 있고, 중간 노드의 메모리는 감소시킬 수 없다.  


## 삼진 검색 트리

이 표현법은 존 벤틀리(Jon Bentley)와 세지윅(Sedgewick)에 의해 처음 제시되었다.  
삼진 검색 트리는 이진 검색트리와 트라이의 장점을 취한다.  
즉 BST의 메모리 효율성과 트라이의 시간 효율성을 결합한다.  
삼진 검색 트리(Ternary Search Tree)는 3개의 포인터를 사용한다.  

* left포인터는 data보다 알파벳적으로 작은 모든 문자열을 가지고 있는 TST를 가리킨다.
* right포인터는 data보다 알파벳적으로 큰 모든 문자열을 가지고 있는 TST를 가리킨다.
* eq포인터는 data와 알파벳적으로 같은 모든 문자열을 가지고 있는 TST를 가리킨다. 
	* 즉, 어떤 문자열을 검색할 때, 입력 문자열의 현재 글자와 TST의 현재 노드의 data가 같다면 
	* 입력 문자열의 현재 글자와 TST의 현재노드의 data가 같다면 입력 문자열의 다음 글자로 진행해서 그것을 eq가 가리키는 부속 트리에서 검색해야 한다.  

### 삼진 검색 트리에 문자열 삽입하기

## BST와 트라이, TST비교하기

* 해시 테이블과 BST 구현은 전체 문자열을 각 노드에 저장한다. 그 결과 검색에 더 많은 시간이 걸린다. 하지만 메모리 사용이 효율적이다.  
* TST는 동적으로 커지고 작아질 수 있다. 하지만 해시 테이블은 적재율에 따라서만 크기가 조절된다.  
* TST는 부분 검색을 허용하고 BST와 해시 테이블은 허용하지 않는다.  
* TST는 단어들을 정렬된 순서로 출력할 수 있지만 해시 테이블에서는 정렬된 순서로 얻을 수 없다.  
* 트라이는 검색 연산을 매우 빠르게 수행하지만 문자열을 저장하는 데 매우 큰 메모리 공간을 필요로 한다. 
* TST는 BST와 트라이의 장점을 결합한다. 즉, BST의 메모리 효율성과 트라이의 시간 효율성을 결합한다.  
	
## 접미어 트리

접미어 트리(Suffix Tree)는 중요한 문자열 데이터 구조 중 하나이다.  
