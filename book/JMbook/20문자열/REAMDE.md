# 문자열(String)

현대의 컴퓨터는 많은 양의 문자열 자료를 다룬다.   
문서 파일, 인터넷의 웹 페이지, 이메일 그리고 문자 메시지들이 모두 다 문자열이다.  
때문에 문자열을 다루는 문제와 자료 구조는 전산학의 중요한 연구 주제이며,  
정보 검색(information retrieval)이나 생물 정보학(bioinformation)분야에서 특히 유용하게 사용된다.  


하지만 여기서는 비교적 간단하게 접할 수 있는 문자열 알고리즘만 다루고 넘어간다.  
이 장에서는 문자열 검색 문제를 위한 KMP알고리즘과, 이에 대한 전처리로 사용하는 접미사 배열(suffix array)를 소개하고,  
이 들로 해결할 수 있는 문제의 예를 보여준다.  


## 용어정의

이 장에서는 다양한 용어가 등장한다.  
예를 들어, 부분 문자열(substring), 접두사(prefix), 접미사(suffix)같은 용어를 많이 다룬다.  
표현을 간결하게 하기 위하여 다음과 같은 표기들을 정의하도록 한다.  

* 문자열 S의 길이는 |S|로 표기한다. 예를 들어 S = "avada" 일 때 |S| = 5이다.  
* 문자열의 인덱스
* 부분 문자열의 정의
* 접두사의 정의
* 접미사의 정의

...(중략)...

## 문자열 검색

주어진 긴 문자열 H에 대해서 문자열 H가 문자열 P를 부분 문자열로 포함하는지 확인하고,  
포함한다면 P와 일치하는 부분 문자열의 시작 위치를 찾는 문제를 문자열 검색 문제라고 한다.  
H = "hogwarts", P = "warts"라고 한다면, H[2...6] = P이므로 H는 P를 포함하여, N의 시작위치는 2가 된다.  
만약 P가 두 번 이상 출현한다면 문자열 검색 알고리즘은 P가 출현하는 모든 위치를 반환해야 한다.  
예를 들어 "avava"는 "ava"를 두 번 포함하며, 각각의 시작 위치는 0, 2이다.  

이 문제를 푸는 가장 간단한 방법을 구현한 C++코드를 소개한다.  

```{.cpp}
vector<int> naiveSearch(const string& H, const string& P)
{
	vector<int> ret;
	bool matched = true;
	int begin, i;

	// 모든 시작 위치를 다 시도해본다.  
	for(begin = 0; begin + P.size() <= H.size(); begin++){
		for(i = 0; i < P.size(); i++){
			if(H[begin + i] != P[i]){
				matched = false;
				break;
			}
		}
		if(matched) ret.push_back(begin);
	}

	return ret;
}
```

이 알고리즘은 대부분의 위치에서 한 번 아니면 두 번의 비교로 불일치를 찾아낼 수 있기 때문에,  
이 알고리즘도 충분히 효율적인 것처럼 보인다. 
그러나 이 알고리즘은 특정 형태의 입력에 대해서는 엄청나게 비효율적으로 동작한다.  
한 예로 P와 H이 모두 a로만 구성된 긴 문자열이라고 하자. 이 경우 모든 시작 위치가 답이된다.  
그러나 단순한 문자열 검색 알고리즘은 그걸 알리가 없으므로, |H| - |P| + 1개의 모든 시작 위치에 대해서 비교를 수행한다.  
대개 |H| >> |P|이므로 시작 위치의 수는 O(|H|)라고 할 수 있다. 각각의 비교에는 O(|P|)의 시간이 걸리기 때문에,  
이와 같은 단순한 알고리즘의 전체 시간 복잡도는 O(|H| \* |P|)가 된다.  


입력이 큰 경우 이 알고리즘은 상당히 비효율적이지만, 사실 이런 경우는 흔치 않다.  
게다가 구현이 단순하다는 장점이 있기 때문에 단순한 알고리즘은 표준 라이브러리의 구현에 널리 사용된다.  
C의 strstr(), C++ 문자열의 string::find(), 자바 문자열의 indexOf()등이 모두 이와 같은 알고리즘을 사용한다.  


## KMP 알고리즘

어떤 긴 문자열에서 P = "aabaabac"를 찾는 경우를 예로 들어보도록 하자.  
시작 위치 i에서부터 P를 맞춰보니 첫 일곱 글자 "aabaaba"는 서로 일치했지만 여덞 글자에서 불일치가 발생했다고 하자.  
단순한 알고리즘은 i가 답이 아니라고 생각하고 i + 1부터 다시 답을 찾기 시작하지만, 
사람이 보면 그렇게 할 필요가 없다고 알 수 있습니다. 
즉, 지금까지 일곱 글자가 대응되었다는 사실을 이용하면,  
시작 위치 중 일부는 답이 될 수 없음을 보지 않아도 알 수 있기 때문이다.  


위치 i에서 일곱 글자가 일치하기 위해서는 H의 해당 부분 문자열인 H[i...i+6]이 "aabaaba"이어야 한다.  
그렇다면 i + 1에서 시작하는 P은 H와 일치할 수가 없다. N[1]은 a인데 H의 대응하는 글자는 b임을 우리가 이미 알고 있기 때문이다.  
이렇게 i+6까지의 시작 위치를 하나하나 시도해 보면 답이 될 가능성이 있는 시작 위치는 i+3과 i+6밖에 없다는 것을 알 수 있다.  
따라서 위치를 i+3으로 증가시키고 검색을 계속하면 될 것이다.  


이 때 놀라운 것은 우이가 시작 위치 후보들을 걸러낼 때 쓴 정보는 오직 
**'현재 시작 위치에서 H와 P를 비교했을 때 몇 글자나 일치 했는가'**뿐이며  
현재 H내에서의 위치나 H에 포함된 문자들은 볼 필요도 없다는 것이다.  


일치한 글자의 수는 항상 0에서 |N|사이의 정수이기 때문에, 전처리 과정에서 이 정보들을 미리 계산해서 저장해 둘 수 있다.  
이와 같은 최적화를 적용한 문자열 검색 알고리즘이 크누스-모리스-프랫 알고리즘으로, 흔히 KMP알고리즘이라고 부른다.  
KMP알고리즘은 다양한 문자열 검색 알고리즘 중 비교적 이해하기 힘든 편에 속하지만,   
KMP알고리즘의 아이디어는 여러 문자열 문제에 응용될 수 있기 때문에 아주 중요하다.  


## 다음 시작 위치 찾기

KMP알고리즘은 앞에서도 설명했듯이, 불일치가 일어났을 때 지금까지 일치한 글자의 수를 이용해 다음으로  
시도해야 할 시작 위치를 빠르게 찾아낸다.  


문자열H와 P가 있을 때 시작 위치 i에서 H와 P를 맞춰봤을 때 matched글자가 일치하고 다음 글자가 불일치한 상황을 보여준다.  
matched글자가 일치했기 때문에, P의 접두사 P[...matched-1]가 H[i...i+matched-1]와 일치했음을 알 수 있다.  


정리하면, 시작 위치 i+k에서 답을 찾을 수 있기 위해서는 N[...matched-1]의 길이 matched-k인 접두사와 접미사가 같아야 한다.  
그러므로 답이 될 수 있는 바로 다음 위치를 찾기 위해서는 N의 각 접두사에 대해 접두사도 되고 접미사도 되는  
문자열의 최대 길이를 계산해 두면 될 것이다.  예를 들어, 앞에서 살펴보았던 KMP 알고리즘의 적용사례를 들어보자. 
H = "aabaaba"의 접두사도 되고 접미사도 되는 문자열은 "aaba"와 "a"의 두 가지가 있지만, 
해당 예에서는 "aaba"를 이용해 시작 위치를 3만큼 옮겨서 더 빠르게 찾고자하는 문자열을 검색할 수 있었다.  


KMP알고리즘은 전처리 과정에서 다음과 같이 정의되는 배열 pi[]를 계산한다.  

> pi[i] = N[...i]의 접두사도 되고 접미사도 되는 문자열의 최대 길이

pi[]는 N이 어디까지 일치했는지가 주어질 때 다음 시작 위치를 어디로 해야할지를 말해 주기 때문에,  
이를 흔히 부분 일치 테이블(partial match table)이라고 부른다.  
다음 표를 보면 각 접두사에 대해 KMP알고리즘이 미리 계산해 두는 부분 일치 테이블의 값들을 보여준다.  

| i |  N[...i] | 접두사이면서 접미사인 최대 문자열 | pi\[i\] \(failure function\) |
|:-:|:--------:|:---------------------------------:|:------------------------:|
| 0 |     a    |               (없음)              |             0            |
| 1 |    aa    |                 a                 |             1            |
| 2 | aab      | (없음)                            | 0                        |
| 3 | aaba     | a                                 | 1                        |
| 4 | aabaa    | aa                                | 2                        |
| 5 | aabaab   | aab                               | 3                        |
| 6 | aabaaba  | aaba                              | 4                        |
| 7 | aabaabac | (없음)                            | 0                        |


## 실제 문자열 검색의 구현

적절한 전처리 과정을 통해 pi[]를 계산했다고 합시다. 이제 문자열 검색을 수행할 준비가 되었다.  
KMP알고리즘은 단순한 알고리즘처럼 시작 위치 0에서 부터 시작해서 H와 P의 글자를 비교한다.  
만약 matched글자가 일치한 후 불일치가 발생했다고 하자. 다음으로 시도해야 할 시작 위치는 어디일까?  
A의 길이는 pi\[matched-1\]이다. 따라서 시작 위치를 matched-pi\[matched-1\]만큼 증가시키면 된다.  


여기서 깨달아야 할 중요한 점은 시작 위치를 움직인 이후 첫 글자부터 다시 대응시켜 나갈 필요가 없다는 것이다.  
새로운 위키에서 비교를 시작하더라도 P의 첫 pi[matched-1]글자는 대응되는 H의 글자와 일치한다는 사실을  
이미 알고 있기 때문이다. 따라서 matched를 pi[matched-1]으로 변경하고 비교를 계속하면 된다.  


불일치가 발생한 경우는 그렇다 치고, 답을 찾은 경우에는 어떻게 할까?  
우선 현재 시작 위치를 답의 목록에 추가해야 한다는 것 빼고는 불일치가 발생한 경우와 똑같다.  
그러고 나면 답이 될 수 있는 다음 시작 위치에서부터 검색을 계속하면 된다.  


다음은 해당 알고리즘을 구현한 코드이다. 문자 비교가 실패했을 때 matched = 0인 경우를 예외 처리한 것을 눈여겨보자.  
한 글자도 일치하지 않고(matched = 0) 불일치가 발생했을 때 우리가 할 수 있는 일은  
바로 다음 시작 위치에서 처음부터 검색을 재개하는 것 뿐이다.  

```{.cpp}
vector<int> kmpSearch(const string& H, const string& P){
	int n = H.size(), m = P.size();
	vector<int> ret;
	// p[i] = N[..i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이
	vector<int> pi = getPartialMatch(P);

	// begin = matched = 0에서부터 시작한다.
	int begin = 0, matched = 0;
	while(begin <= n - m){
		// 만약 H의 해당 글자가 바늘의 해당 글자와 같다면
		if(matched < m && H[begin + matched] == P[matched]){
			++matched;
			// 결과적으로 m글자가 모두 일치했다면 답에 추가한다.
			if(matched == m) ret.push_back(begin);
		} else {
			// 예외: matched가 0인 경우에는 다음 칸에서부터 계속
			if(matched == 0){
				++begin;
			} else {
				begin += matched - pi[matched-1];
				// begin을 옮겼다고 처음부터 다시 비교할 필요가 없다.
				// 옮긴 후에도 pi[matched-1]만큼은 항상 일치하기 때문이다.
				matched = pi[matched-1];
			}
		}
	}

	return ret;
}
```

## 시간 복잡도 분석

이제 시간 복잡도를 분석해 보자. 아직 pi[]를 계산하기 위한 getPartialMatch()의 구현을 다루지 않았기 때문에  
이 부분을 제외하고 생각해보자. kmpSearch()의 수행 시간을 지배하는 while문은 if문의 분기 결과에 따라 다른 동작을 하기 때문에  
수행 시간을 분석하기 어려워 보이지만 if문의 각 분기 내용이 최대 몇 번이나 수행되는지를 각각 계산해서  
이 알고리즘의 수행 시간을 분석할 수 있다.  


while문 내부의 첫 번째 if문은 최대 몇번이나 성공할까?   
우선 깨달아야 할 것은 while문 내에서 begin + matched는 절대 감소하지 않는다는 것이다.  
matched가 감소할 때도 begin은 항상 그 감소분 만큼 증가하기 떄문에 둘의 합은 변하지 않는다.  
따라서 한번 matched가 증가하고 나면, H[begin + matched]를 다시 참조할 일은 전혀 없다.  
따라서 문자 비교 성공은 짚더미의 각 문자당 최대 한 번씩만 일어날 수 있고,  
결과적으로는 이 분기는 최대 O(|H|)번 수행된다는 것을 알 수 있다.  


이 if문의 비교가 최대 몇 번이나 실패할지 생각해보자.  
begin은 0에서 시작해, 이 분기가 수행될 때마다 1이상씩 증가한다.  
전체 알고리즘은 begin이 |H| - |P|을 초과하면 곧장 종료하기 때문에, 이 분기는 최대 O(|H|)이다.  
따라서 kmpSearch()의 반복문의 전체 수행 횟수는 O(|H|)이다. P의 길이와는 상관없이 항상 H의 길이에만 비례하는 것이다.  


## 부분 일치 테이블 생성하기

이제 앞에서 빼놓은 getPartialMatch()를 어떨게 구현할지에 대해 알아보자.  
이 부분은 KMP검색 과정을 응용하면 속도가 빠른 함수를 구현할 수 있기 때문에 뒤로 빼놓았다.  


우선 이 함수를 구현하는 가장 간단한 방법을 만든 뒤 이것을 단계적으로 최적화해 나가자.  
부분 일치 테이블을 만드는 가장 간단한 방법은 P의 각 접두사에 대래 가능한 답을 하나씩 모두 시도하는 것이다.  
길이 P인 접두사 P[...p-1]이 주어졌을 때 길이 p-1인 접두사, 길이 p-2인 접두사, 길이 p-3인 접두사들을 순회하며  
이들이 P[...p-1]의 접미사가 되는지를 확인하는 것이다. 이 과정을 그대로 구현하면 각 접두사 길이의 제곱에  
비례하는 시간이 걸리기 때문에, |P|개의 모든 접두사에 대해 수행하려면 O(|P|^3)의 시간이 걸린다.  


대개 |P|는 |H|에 비해 훨씬 작기 때문에 이것만으로도 충분한 경우도 많지만, 이것을 좀 더 최적화할 수 있는 방법이 있다.  
각 접두사에 대해 pi[]의 값을 따로 계산하는 것이 아니라 모든 접두사에 대해 한꺼번에 계산하는 것이다.  
예를 들어, P = "aabaabac"에서 자기 자신을 찾는 단순한 알고리즘의 동작 과정을 생각해보자.  
여기서 첫 다섯 글자를 잘라보면 이 원리를 알 수 있다.  
따라서 두 글자 P[i]와 P[begin + i]가 일치할 때마다 pi[begin+i]를 갱신해주면 단순한 문자열 검색에 걸리는 시간인  
O(|P|^2)만에 부분 일치 테이블을 계산할 수 있다.  


다음 코드는 이와 같은 알고리즘의 구현을 보여준다.  
단순한 문자열 검색을 구현했던 앞선 코드와 별로 다를 것이 없지만, 답을 찾을 가능성이 없더라도  
[1, |P|-1]의 모든 시작 범위를 시도한다는 점과 일치가 일어날 때마다 pi[]를 갱신한다는 점이 다르다.  
여기서 pi[begin+i]를 갱신할 때 이미 있는 값과 i+1중 더 큰 값을 택한다는 점을 눈여겨 보자.  
현재보다 왼쪽에 있는 시작 위치에서 이 위치에 값을 이미 갱신했을지도 모르기 때문이다.  


```{.cpp}
// P에서 자기 자신을 찾으면서 나타나는 부분 일치를 이용해서 
// pi[]를 계산한다.
// pi[i] = P[..i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이
vector<int> getPartialMatchNaive(const string& P){
	int m = P.size();
	int begin, i;
	vector<int> pi(m, 0);

	// 단순한 문자열 검색 알고리즘을 구현한다.
	for(begin = 1; begin < m; ++begin){
		for(i = 0; i + begin < m; ++i){
			if(P[begin + i] != P[i]) break;
			// i+1 글자가 서로 대응되었다.
			pi[begin + i] = max(pi[begin+i], i+1);
		}
	}

	return pi;
}
```

그런데 기왕이면 이러한 검색 과정을 KMP알고리즘으로 구현해 보면 어떨까?  
다음 코드는 KMP검색을 이용하여 부분 일치 테이블을 생성하는 getPartialMatch()의 구현을 보여준다.  
역시 일치가 일어날 때 마다 pi[]를 갱신하는 것만 제외하면 kmpSerach()와 거의 똑같은 것을 알 수 있다.  
이 외에도 몇 가지 재미있는 점이 있다. 다음과 같은 점을 눈여겨보자.  

* begin을 옮길 때 이전에 계산한 pi[]값을 사용하고 있다.
	* 현재 글자가 matched에 일치했다면 pi[matched-1]는 항상 계산된 뒤임을 증명할 수 있기 때문이다.  

* pi[]의 각 원소는 최대 한 번만 변경되기 때문에 getPartialMatchNaive()에서처럼 max()연산을 따로 해줄 필요가 없다.  

```{.cpp}
// P에서 자기 자신을 찾으면서 나타나는 부분일치를 이용해서 
// pi[]를 계산한다. 
// pi[i] = P[..i]의 접미사도 되고 접두사도 되는 문자열의 최대 길이
vector<int> getPartialMatch(const string& P){
	int m = P.size();
	vector<int> pi(m, 0);

	// KMP로 자기 자신을 찾는다.
	// P를 P에서 찾는다. begin = 0이면 자기 자신을 찾아버리므로 안된다.
	int begin = 1, matched = 0;
	// 비교할 문자가 P의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 기록한다.
	while(begin + matched < m){
		if(P[begin + matched] == P[matched]){
			++matched;
			pi[begin+matched-1] = matched;
		} else {
			if(matched == 0)
				++begin;
			else{
				begin += matched - pi[matched-1];
				matched = pi[matched-1];
			}
		}
	}

	return pi;
}
```

KMP 문자열 검색을 그대로 이용하기 떄문에 이 전처리 과정의 시간 복잡도는 O(|P|)가 된다.  
따라서 두 과정의 시간 복잡도를 합치면 전체 O(|N| + |H|)가 된다.  
여기에 딸린 문제는 다른 문서에서 따로 풀어보도록 한다.

# 접미사 배열

문자열을 다룰 때 빼놓을 수 없는 자료 구조로 접미사 배열(suffix array)가 있다.  
접미사 배열은 굉장히 다양한 문자열 문제를 푸는 데 사용할 수 있다.  


거창한 이름과는 달리, 접미사 배열은 사실 아주 간단한 자료구조다. 
어떤 문자열 S의 모든 접미사를 사전 순으로 정렬해 둔 것이다. 
물론 이 말을 말 그대로 따라서 배열을 만들게 되면 문자열 길이의 제곱에 비례하는 메모리가 필요하게 된다.  
따라서 메모리 절약을 위해 대게 접미사 배열은 각 접미사의 시작 위치를 담는 정수 배열로 구현된다.  
다음 표는 문자열 "alohomora"의 접미사 배열 A[]와 각 위치에서 시작하는 접미사들을 보여준다.  

| i | A[i] | S[A[i]...] |
|---|------|------------|
| 0 | 8    | a          |
| 1 | 0    | alohomora  |
| 2 | 3    | homora     |
| 3 | 1    | lohomora   |
| 4 | 5    | mora       |
| 5 | 2    | ohomora    |
| 6 | 4    | omora      |
| 7 | 6    | ora        |
| 8 | 7    | ra         |

## 접미사 배열을 이용한 검색

접미사 배열을 이용해 할 수 있는 대표적인 일로 문자열 검색이 있다.  
접미사 배열을 이용한 문자열 검색은 문자열 H가 문자열 P를 포함한다면 항상 P는 H의 어떤 접미사의 접두사라는 점을 이용한다.  
예를 들어 "alohomora"에서 "homo"를 찾는다고 하자. "homo"는 S의 접미사인 "homora"의 접두사가 된다.  
모든 부분 문자열에 대해 이 속성이 성립함을 쉽게 알 수 있다.  
이 속성을 이용하면 H의 접미사 배열을 이진 탐색해서 각 문자열이 출현하는 위치를 찾을 수 있다.  
접미사 배열의 길이는 항상 |H|이므로 이진 탐색의 내부는 O(lg|H|)번 수행된다.  
각 문자열 비교에 O(|N|)시간이 걸리기 때문에 이 이진 탐색의 수행 시간은 O(|N|lg|H|)이 된다.  
물론 전처리 과정에서 짚더미의 접미사 배열을 생성해야 한다는 부담이 있지만,   
같은 H에서 P를 찾아야 한다면 이 알고리즘은 아주 유용할 것이다.  


## 접미사 배열의 생성

접미사 배열을 만드는 가장 간단한 방법은 우리가 늘상 사용하는 일반적 정렬 알고리즘을 사용하는 것이다.  
문자열의 길이가 n일 때[0, n-1]범위의 정수를 모두 담은 정수 배열을 정렬하되,  
두 정수를 비교할 때 해당 위치에서 시작하는 접미사들을 비교한다.  
다음 코드는 이와 같이 별도의 비교자를 구현해 C++ STL의 sort함수로 접미사 배열을 만드는 함수의 구현을 보여준다.  

```{.cpp}
// 두 접미사의 시작위치 i, j가 주어질 때 두 접미사 중 어느쪽이 앞에 와야 할지 비교한다.
struct SuffixComparator{
	const string& s;
	SuffixComparator(const string& s) : s(s) {}
	bool operator() (int i, int j){
		// s.substr() 대신에 strcmp()를 쓰면 임시 객체를 만드는 비용이 절약된다.
		return strcmp(s.c_str() + i, s.c_str() + j) < 0;
	}
};

// s의 접미사 배열을 계산한다.
vector<int> getSuffixArrayNaive(const string& s){
	// 접미사의 시작위치를 담은 배열을 만든다.
	vector<int> perm;
	int range, i;

	range = s.size();
	for(i = 0; i < range; ++i)
		perm.push_back();
	// 접미사를 비교하는 비교자를 이용해 정렬하면 완성!
	sort(perm.begin(), perm.end(), SuffixComparator(s));
	return perm;
}
```

그렇다면, 이 코드의 시간 복잡도는 얼마일까? sort()의 시간 복잡도는 O(n\*log(n))이지만,  
이것은 두 원소의 비교에 상수 시간이 걸릴 때 이야기이다.  
두 문자열을 비교하는 데는 최대 두 문자열의 길이에 비례하는 시간이 걸리므로, 한번 비교에 O(n)시간이 걸린다고 할 수 있다.  
sort()는 O(n\*log(n))번의 비교를 수행하므로, 전체 시간 복잡도는 O(n^2\*log(n))가 된다.  


이 시간 복잡도는 못 써먹을 정도로 크다고 생각할 수도 있지만,  
실제로는 모든 글자를 다 비교할 것 없이 첫 몇 글자만으로도 어느 쪽이 큰지 판단할 수 있는 경우가 많다.  
덕분에 이 코드의 수행 시간은 예상보다 짧은 경우가 대부분이다.  
하지만 "aaa...aaaaa"같은 문자열이 주어진다면 모든 비교가 문자열 끝까지 이루어지기 때문에 아주 오랜 시간이 걸린다.  

## 접미사 배열을 만드는 맨버-마이어스의 알고리즘

getSuffixArrayNaive()는 대부분의 경우 빠르게 동작하지만,  
모든 형태의 입력에 대해 시간안에 동작해야 하는 프로그래밍 대회에서 사용하기에는 무리가 있다.  
따라서 좀 더 빠른 알고리즘을 사용해야한다. 놀랍게도 접미사 배열을 만드는 가장 빠른 알고리즘은 선형 시간  
즉, O(n)시간에 동작한다. 하지만 이런 알고리즘들은 구현이 너무 복잡한 관계로 시간이 제한되어 있는 대회에서 구현하기에는  부적절하다.  
따라서 대회 참가자들은 많은 경우 적절히 빠른 속도를 제공하면서 구현이 간편한 알고리즘을 사용하게 된다.  
이 장에서 소개할 알고리즘은 접미사 배열을 처음 제안한 논문에서 제시한 알고리즘으로, 우리가 정렬하는 문자열들이  
한 문자열의 접미사라는 점을 이용해 수행시간을 낮춘다.  


이 알고리즘은 접미사의 목록을 여러 번 정렬하는데, 매번 그 기준을 바꾼다.  
처음에는 접미사의 척 한 글자만을 기준으로 정렬하고, 다음에는 접미사의 첫 두 글자를 기준으로 정렬하고, 
그 다음에는 접미사의 첫 네 글자를 기준으로 정렬한다. 이렇게 log(n)번의 정렬을 하고 나면 우리가 원하는 접미사 배열을 얻게 된다.  
다음 표를 보면 "mississipi"의 접미사들을 첫 한 글자, 두 글자, 네 글자, 여덟 글자를 보고 정렬했을 때의 결과를 보여준다.  
이렇게 정렬을 여러 번 하는데도 더 빠르게 동작하는 이유는 이전 정렬에서 얻은 정보를 이용하여  
두 문자열의 대소 비교를 O(1)에 할 수 있기 때문이다.  


첫 글자를 기준으로 접미사들을 정렬한 결과를 가지고 있다고 하자.  
각 접미사들을 첫 글자가 같은 것들끼리 그룹으로 묶고, 각 그룹마다 0부터 시작하는 번호를 매긴다.  
위의 표의 맨 왼쪽 표는 첫 글자를 기준으로 문자열들을 어떨게 묶을 수 있는지 보여준다.  
이 경우 i로 시작하는 접미사들은 0번 그룹, m으로 시작하는 접미사들은 1번 그룹, p로 시작하는 접미사들은 2번 그룹,  
s로 시작하는 접미사들은 3번 그룹으로 묶이게 될 것이다.  
이제 다음과 같은 배열 group[]을 만들어보자.  

> group[i] = S[i...]가 속한 그룹의 번호  

접미사들을 정렬하고 나면 group[]을 만들기란 간단하다. 접미사들을 맨 앞에서부터 순회하면서  
각 접미사에 그룹 번호를 부여한다. 첫 접미사에는 항상 그룹 번호 0번을 주고, 그 이후부터는 이전 접미사와 첫 글자가 같으면  
이전 접미사의 그룹 번호를, 아니면 이전 접미사의 그룹 번호에 1을 더한 번호를 부여하면 된다.  
첫 t글자를 기준으로 만든 group[]이 있으면 두 접미사 S[i...], S[j...]중 첫 t글자를 기준으로  
어느 쪽이 더 앞에 오는지를 쉽게 알 수 있다. group[i]와 group[j]중 어느 쪽이 더 작은지를 확인하면 되기 때문이다.  


그런데 이것만 있으면 S[i...]와 S[j...]중 첫 2t글자를 기준으로 어느 쪽이 사전에서 앞에 오는지도  
상수 시간에 판단할 수 있다. 어떻게 할까?  
S[i...]와 S[j...]가 주어질 때, 우선 첫 t글자를 비교한다. 만약 이들이 서로 다르다면 나머지를 볼 것도 없이  
앞에 오는지 결정할 수 있다. 만약 두 접미사가 같은 그룹에 속한다면 어떻게 해야 하나?  
S[i+t...]와 S[j+t...]의 첫 t글자를 서로 비교하면 된다.  


다음 코드는 이와 같은 방식을 비교한 비교자를 보여준다.  
이 비교자를 만들고 나면 이제 첫 2t글자를 기준으로 해서 접미사들을 O(n\*log(n))시간에 정렬할 수 있다.  
그러고 나면 다시 이들을 순회하면서 O(n)시간에 그룹으르 지을 수 있다.  

```{.cpp}
// 각 접미사들의 첫 t글자를 기준으로 한 그룹 번호가 주어질 때,
// 주어진 두 접미사를 첫 2*t글자를 기준으로 비교한다.  
// group[]은 길이가 0인 접미사도 포함한다. 
struct Comparator{
	const vector<int>& group;
	int t;
	Comparator(const vector<int>& _group, int _t): group(_group), t(_t){
		group = _group; t = _t;
	}

	bool operator () (int a, int b){
		// 첫 t글자가 다르면 이들을 이용해 비교한다.
		if(group[a] != group[b]) return group[a] < group[b];
		// 아니라면 S[a+t..]와 S[b+t..]의 첫 t글자를 비교한다.
		return group[a+t] < group[b+t];
	}
};
```

여기서 group[a+t]과 group[b+t]가 혹 배열 범위 밖의 값이 아닌지 확인하지 않는다는 점을 눈여겨 보자.  
어떻게 이런 일이 가능한가? 이 두 값을 참조하는 경우는 두 접미사의 첫 t글자가 같을 때 뿐인데,  
그러기 위해서는 두 접미사의 길이는 모두 t이상이어야 한다.  
따라서 이 경우 a+t와 b+t는 최대 n이다. 따라서 group[n]을 아주 작은 값으로 두면 범위 확인 없이 모든 경우를 처리할 수 있다.  
이 비교자를 사용하는 전체 알고리즘의 구현을 다음 코드에서 볼 수 있다.  

```{.cpp}
// s의 접미사 배열을 계산한다.
vector<int> getSuffixArray(const string& s){
	int n = s.size();
	// group[i] = 접미사들을 첫 t글자를 기준으로 정렬했을 때,
	// 			  S[i..]가 들어가는 그룹 번호
	// t = 1일때는 정렬할 것 없이 S[i..]의 첫 글자로 그룹 번호를 정해줘도 같은 효과가 있다.
	int t = 1, i;
	vector<int> group(n+1);
	for(i = 0; i < n; ++i) group[i] = s[i];
	group[n] = -1;
	// 결과적으로 접미사 배열이 될 반환 값. 이 배열을 log(n)번 정렬한다.  
	vector<int> perm(n);
	for(i = 0; i < n; ++i) perm[i] = i;

	while(t < n){
		// group[]은 첫 t글자를 기준으로 다시 정렬한다.
		// 첫 2t글자를 기준으로 perm을 다시 정렬한다.
		Comparator compareUsing2T(group, t);
		sort(perm.begin(), perm.end(), compareUsing2T);

		// 2t글자가 n을 넘는다면 이제 접미사 배열 완성!
		t *= 2;
		if(t >= n) break;

		// 2t글자를 기준으로 한 그룹 정보를 만든다.
		vector<int> newGroup(n+1);
		newGroup[n] = -1;
		newGroup[perm[0]] = 0;
		for(i = 1; i < n; ++i)
			if(compareUsing2T(perm[i-1], perm[i]))
				newGroup[perm[i]] = newGroup[perm[i-1]] + 1;
			else
				newGroup[perm[i]] = newGroup[perm[i-1]];
		group = newGroupl
	}

	return perm;
}
```

