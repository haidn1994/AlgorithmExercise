/*
	이 문제를 다이나믹으로 푸는 방법은 2가지다.
	첫번째로는 1차원 배열을 사용하는 방법이 있고, 두번째로는 2차원 배열을 사용하는 방법이 있다.
	1차원 배열을 사용하게 되면 "상태"를 나타내는 배열과 "값"을 나타내는 배열 2가지를 사용한다.
	하지만 귀찮은 예외처리를 꽤 많이 해줘야 한다. 이는 코드가 알아보기 쉽게 나오지 않음을 의미하고
	버그가 생길 가능성이 증가함을 뜻한다. 그럼 2차원 배열을 사용한 풀이는 어떨까?

	2차원 배열을 사용하더라도 상태를 나타내는 배열과 값을 나타내는 배열을 사용하게 되는 것은 매한가지이며,
	오히려 메모리를 더 많이 잡아먹게 된다. 하지만 더 많은 메모리를 사용함으로써 얻을 수 있는 이점은
	귀찮은 예외사항을 처리하여 버그의 가능성을 줄여주는 데 있다. 

	내가 앞서 만든 코드가 틀린이유는 2차원 배열 풀이와 1차원 배열 풀이를 혼동하여 소스코드를 작성하였기 때문이다.
	그리고 다이나믹 프로그래밍을 공부하면서 느낀 점은 다음 3가지이다. 명심하도록 한다.

	1. 다이나믹 테이블에 어떤 값이 들어갈지를 정하는 것이 제일 중요하다.
	   쉬운 문제들은 1차원 배열만 사용하고, 순진하게 문제에서 제시해주는 조건을 집어넣고
	   top-down으로 푼다면 적당한 기저사례를 적어주고, bottom-up으로 푼다면 적당한 초기값만 넣어주면 된다.
	   여기에 적절한 점화식을 세우면 문제는 그냥 풀린다. 

	   그리고 여태까지 물어본것은 "모든 경우의 수", "~의 최대/최소값"등이거나 둘 중 하나로 귀결할 수 있다.
	   모든 경우의 수는 그저 경우를 나누어 모두 더하면 된다. 하지만 최대/최소는 반드시 조건문이 들어가거나,
	   비교하는 함수(std::max(begin, end), 또는 std::min(begin, end)등)을 사용하여 경우를 구분하고
	   문제에서 원하는 값을 내보내야 한다. 이 정도까지만 지켜주면 문제는 풀린다.

	   하지만 문제풀이-2부터는 상황이 달라지는데, 지금까지 본 상황은 다음과 같다.
	   1. 2차원 배열을 통해서 경우를 보다 구체적으로 나눠야 함:
	      예를 들어 계단 수 문제나 오르막 수 문제는 (예, 아니오)로 나누어지는 것이 아니라 
		  각 부분 문자열마다 맨 뒤에 10개의 문자가 올 수 있는데, 그 상황을 각각 고려해야 한다.
		  따라서 단순히 점화식을 잘 세우거나 조건문을 잘 세우는 것으로 때우기 어렵다.
		  2차원 배열을 만들어써야 한다. 그리고 2차원 배열이상부터는 각 차원에 무엇이 들어올지
		  잘 나눠서 표현해야 한다. 주의하자

	   2. "상태"를 표현하는 또 다른 테이블이 필요할 수도 있다.
	      (type이 반드시 bool일 필요는 없다. 명시적으로 상태를 나타낼 이유는 없는 것 같고, 
		  문맥상 구분할 수 있게 해주는 정도?)
	      스티커 문제나 포도주 시식 문제를 2차원 배열로 푸려고 하면 또 다른 1차원 배열이 1개 더 있는 쪽이 
		  문제를 훨씬 쉽게 푸는데 도움을 준다. 왜일까? "~게 하면 안된다."라는 상황이 오기 때문이다.
		  따라서 상태를 표현하는 배열을 통해 이를 해결해야 한다.

	   3. 문제에 따라 따로 값을 저장해주는 테이블이 필요할 수도 있다.
 */

#include <iostream>
using namespace std;

// a는 포도주의 양을 뜻한다.
int a[10001];
// d는 다이나믹 테이블이다.
int d[10001];

int main(void)
{
	int n; ios_base::sync_with_stdio(false);
	int i;
	cin >> n;
	for(i = 1; i<= n; i++)
		cin >> a[i];

	// 사실 여기까지의 "발상"은 나도 맞았다. 그런데 뒷부분이 틀렸다.
	d[1] = a[1];
	d[2] = a[1] + a[2];
	for(i = 3; i <= n; i++){
		// 여기서 경우는 3가지중 하나로 나누어진다.
		// 1. 0번 연속해서 먹는 경우 -> i번째는 먹지 않음
		// 2. 1번 연속해서 먹는 경우 -> i번째에 먹는다.
		// 3. 2번 연속해서 먹는 경우 -> i번째와 i-1번째에 먹는다.
		d[i] = d[i-1];
		if(d[i] < d[i-2] + a[i])
			d[i] = d[i-2] + a[i];
		if(d[i] < d[i-3] + a[i] + a[i-1])
			d[i] = d[i-3] + a[i] + a[i-1];
	}
	cout << d[n] << '\n';
	return 0;
}
