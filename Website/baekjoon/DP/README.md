# 다이나믹 프로그래밍 문제풀이 전략

먼저 다이나믹 프로그래밍이란 용어에서 다이나믹이라는 말은 아무런 의미가 없다는 점을 기억하라.  
그리고 다이나믹 프로그래밍은 큰 문제를 작은 문제로 나눠서 푸는 알고리즘이라는 사실도 기억하라.  
이제 문제를 푸는 데 있어서 몇 가지 알아낸 전략을 소개하겠다.  

## 다이나믹 프로그래밍 문제인지 어떻게 알죠?

다소 거칠지만 직관적으로 다이나믹 프로그래밍 문제라고 생각할 수 있는 단서를 꼽아보자면 다음과 같다.  

1. "모든 경우의 수를 구하라, 최대값을 구하라, 최소값을 구하라"라는 구절이 문제에 담겨 있다.  
2. 문제를 점화식으로 표현하기 용이해 보이는 경우. 단, 이는 문제를 푸는 사람의 실력에 많이 좌우된다.  

1번 조건의 경우 굉장히 강력한 조건이다.  
대부분의 경우 다이나믹 프로그래밍 문제는 경우의 수, 최대값, 최소값을 구하는 문제를 낸다.  
문제를 점화식으로 표현하기 용이해 보이는 것도 상당히 강력한 조건이지만  
앞서 말했듯이 푸는 사람이 점화식을 잘 이끌어내지 못한다면 그 문제는 못 푸는 것이나 다름 없어지고  
정확하게 잘 끌어낼 수 있다면 반은 푼 것이나 다름 없다.("코드로 잘 표현하는 있는지"는 별개의 문제다.)  


이제 다이나믹 프로그래밍 문제라고 생각할 수 있는 엄밀한 조건을 소개하겠다.  

1. Overlapping Subproblem을 만족하는가?
2. Optimal Subproblem을 만족하는가?

두 조건을 한국말로 직역하면 "겹치는 부분문제", "최적 부분문제"라고 할 수 있다.  
그런데 정확하게 어떤 조건을 말하는 것일까? "겹치는 부분문제" 조건은 어떤 문제를 푸는 데 있어서  
큰 문제를 작은 문제로 쪼갤 수 있으며 그렇게 얻은 작은 문제는 큰 문제를 해결하는 방법과 같은 방법으로 풀 수 있다는 성질이다.  
참고로 작은 문제와 큰 문제는 현재 내가 풀고자 하는 문제에 따라서 상대적이라는 사실도 기억하라.  


그러면 "최적 부분문제"는 어떤 의미를 가지고 있을까? 문제의 정답을 작은 문제의 정답에서 구할 수 있다는 성질  
(예를 들어 작은 문제의 정답끼리 사칙연산등을 통해 얻은 값이 원래 구하고자 하는 문제의 정답)을 가진다면,  
이는 "최적 부분 문제"라고 할 수 있다. 그리고 여기에 더해 중요한 성질이 한 가지 더 있다.  
Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.  
이는 아무 점화식이나 한 가지 풀어본다면 바로 알 수 있다.  


## 문제풀이 전략

다음과 같은 원칙에 따라서 문제풀이 계획을 세운다면 좀 더 수월하게 문제에 접근할 수 있다.  

1. 문제에서 구하려고 하는 답을 문장으로 나타낸다.
	* 위에서 언급한 바에 따라, 보통 3가지로 나뉜다. 모든 경우의 수, 최대값, 최소값  
	* "모든 경우의 수" 라는 조건이 있다면 덧셈을 사용해 말 그대로 "모든 경우의 수"를 나타내자.
	* 최대값을 구하라고 한다면 점화식을 적용하여 부분문제를 풀 때 마다 max(), 또는 \*max\_element를 사용해야 한다.
	* 최소값을 구하라고 한다면 점화식을 적용하여 부분문제를 풀 때 마다 min(), 또는 \*min\_element를 사용해야 한다. 
	* 마지막으로 문제를 푸는 첫번째 단계인 "문제를 이해한다."는 제일 중요한 단계다. 명심하라.

2. 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다. 
	* 배열에 어떤 **값**을 메모할지를 먼저 정해야 한다. 문제에서 구하려고 하는 답을 문장으로 나타내는 것만큼 중요하다. 
	* 문제가 간단하다면 1차원 배열로도 충분하고, 어떤 값을 메모할지 정하는 것도 매우 쉽다. 하지만 2차원 이상으로 간다면?
	* 2차원 이상의 배열을 사용해야 하는 상황이 나온다면 경우를 꼼꼼하게 나누고, 답을 구할때도 경우를 다 더하거나, 최소/최대를 구하는 등의 연산을 해줘야 하는 점을 주의하라.

3. 배열을 만들 때 주의할 점-1
	* "최적 부분문제" 성질에 의해: 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다. 왜? -> 경제적으로 문제를 풀자!
	* Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.  
	* 경제적으로 문제를 풀어야하므로, 정답을 한 번 구했으면 어딘가에 메모해놓고(배열) 필요할 때마다 불러서 사용한다.  

4. 배열을 만들 때 주의할 점-2
	* 배열을 만들거나 top-down방식으로 문제를 풀려고 한다면 필수적으로 **조건을 나눠서** 적절한 **점화식**을 세워야 한다.
	* 이는 다이나믹 프로그래밍 문제를 풀 수 있느냐 없느냐를 결정하는 아주 중요한 사안이다.  

이제 요약해보자.

0. 문제가 다이나믹 프로그래밍으로 풀 수 있는 문제인지 확인한다. 
1. 문제에서 구하려고 하는 답을 문장으로 나타낸다. 만약 최대/최소를 구하라고 하면 꼭 max(), min()등을 사용하는 코드가 있어야 한다. 
2. 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다. 이 때, 배열에 어떤 값을 저장할지 먼저 정한다.  
3. 그 값을 어떻게 구할 것인지를 표현하는 점화식을 문제에서 요구한 바에 따라 만든다. 이 때 각 문제는 한 번씩만 풀도록 점화식을 세운다.  
4. 필요하다면 조건을 정확하게 나누어서 경우에 따른 점화식을 각각 세운다. 특히 다차원 배열이 필요할 때때는 각별히 주의해서 점화식을 세운다.  



