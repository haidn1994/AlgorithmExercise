#include <stdio.h>
// 이 문제는 1로 만들기문제와 완전히 같은 문제라는 것을 인지해야 한다.
// 그리고 이거 메모리 조건이 좀 빡세다.
int d[10001];

// 동전의 종류마다 값을 저장한다.
int coin[101];

// 경우의 수를 구하는 문제이므로 모두 더해야 한다.
// 그런데 그리디 알고리즘하고 다이나믹 프로그래밍하고 무슨 관련이 있을까?
int main(void)
{
	int n, k;
	int i, j;
	scanf("%d %d", &n, &k);
	for(i = 1; i <= n; i++)
		scanf("%d", &coin[i]);

	// 특히 경우의 수를 푸는 문제에서는 d[0] = 1이 매우 유용하다.
	d[0] = 1;
	// 그리고 푸는 방법이 이전까지 보았던 문제와 많이 다른데, 보통 큰 루프가 바깥에 있고,
	// 작은 루프가 안쪽에 있는데, 이건 정반대로 되어 있다. 왜 그럴까?
	for(i = 1; i <= n; i++){
		for(j = 1; j <= k; j++){
			// 음수 인덱싱 보호 및, 동전을 딱 나누어 떨어지게 하기 위함
			if(j - coin[i] >= 0) // 이부분은 맞았다. 아래쪽은 생각못했다.
				d[j] += d[j-coin[i]];
		}
	}   

	printf("%d\n", d[k]);
	return 0;
}

