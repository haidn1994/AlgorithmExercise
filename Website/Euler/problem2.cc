/*
 이 문제를 보면서 여러가지 생각이 들었는데, 예전에 내가 풀었던 풀이를 말로 설명해보면 다음과 같다.

 >> 상태변수를 3개(이전항, 현재항, sum) 놓고 해당 항이 짝수인지 아닌지 검사하고(이 때 효과적인 비트검사 방법이 있다. 참고하자.) 맞으면 sum에 더한다.
 아니면 더하지 않고 그냥 넘어가는 방법을 사용한다.

 하지만 분명히 다른 방법이 있을것이라고 생각했서 여러 자료를 찾아보았는데 다음 링크를 참고하면 좋을 것 같다.

 * https://www.acmicpc.net/blog/view/28
 * https://proofwiki.org/wiki/Fibonacci_Number_3n_in_terms_of_Fibonacci_Number_n_and_Lucas_Number_2n
 * http://euler.synap.co.kr/forum_list.php?p=2&pg=1 => python2 코드임... 주의!

 맨 아래 링크에 내가 찾아 헤매던 답이 있다! 참고해서 C++ 버전으로 작성해보자!

하지만 여기에는 오일러 2번 문제에 대한 직접적인 해결책은 얻을 수 없었다.  
하지만 좋은 아이디어가 떠올랐다.

피보나치 수열의 0번째 항은 짝수이고, 1번째 항은 홀수이다.
그리고 2번째 항부터는 n-2번째 항과 n-1번째 항의 합으로 정의되기 때문에
일정 주기마다 짝수가 등장한다는 사실을 알 수 있다.

홀 + 홀 = 짝수 -> (2n-1) + (2n-1)은 2로 나누어 떨어진다.
홀 + 짝 = 짝 + 홀 = 홀수 -> 2n-1 + 2n = 4n-1은 2로 나누어 떨어지지 않는다.
짝 + 짝 = 짝수 -> 2n + 2n = 4n은 2로 나누어 떨어진다.

피보나치 수열에서는 짝-짝인 항은 연속해서 등장하지 않지만 홀수인 항과 홀수인 항이 0항을 포함해서 3n-1번째항과 3n-2번째 항에서 등장한다는 사실을 알 수 있다. 

이 사실에 착안해서 식을 더 정리하면 O(1)의 알고리즘을 얻을수도 있지만 그대로 반복문으로 옮겨도 보다 아름다운 알고리즘을 만들게 될 것이다.

여기서 알 수 있는 여러가지 주제들

1. 피보나치 수의 주기성 + 홀수와 짝수의 성질
2. 특성 방정식을 통한 피보나치 수의 일반항 구하기 (또는) 행렬을 통한 피보나치 수 계산 최적화
3. 피보나치 수의 여러 성질들
4. 이진 탐색을 응용할 수 있는 여러 조건

이에 대한 구현은 다음 시간에 해보도록 하겠다.
 */

// 첫 번째 구현: 문제에서 말한 그대로 옮기는 방법 -> 반복문 사용시 시간 복잡도 O(n)

// 두 번째 구현: 피보나치 수를 열심히 관찰하다 보면, 0을 포함해서 3n번째 항마다 짝수가 등장한다는 사실을 알 수 있다. 
// 여기에 착안하면 조건문을 사용하지 않고 구할 수 있다.

// 세 번째 구현: 살을 더 붙이면 더 빠르게 구할 수 있다.
// 3-1-1. 특성 방정식을 통해서 피보나치 수열의 일반항을 얻어 O(n)이 아니라 O(1)의 속도로 피보나치 수를 구할 수 있다.(수학적으로 최적화)
// 하지만 식에 제곱근이 들어가 있어서 수치가 부정확하게 나올 가능성을 염두에 두어야 한다.

// 3-1-2. 또는 행렬을 통해서 피보나치 수를 구하면 위에서 언급한 일반항을 통해 피보나치 수를 구하는 방법보다는 시간 복잡도가 좋지 않지만 
// O(n)보다는 매우 준수한 속도로 피보나치 수를 구할 수 있다.(분할 정복법)

// 3-2. 문제에서 제시하는 조건을 살펴보면 피보나치 수의 크기(4백만 이하, 치역)를 조건으로 제시하고 있는데 
// 우리가 알고 있는 피보나치 수의 성질들은 거의다 정의역(자연수)과 관련되어 있다. 
// 따라서 적절한 항을 찾기 위해서는 다른 방법을 사용해서 한다. 이제 다음 조건을 고려해보자.

// 1. 피보나치 수는 정의역으로 0을 포함하는 자연수를 가진다.
// 2. 모든 피보나치 수는 오름차순으로 정렬되어 있다.  
// 3. 조건으로 4백만 이하의 피보나치 수를 제시한다.

// => 이진 탐색을 응용할 수 있는 이상적인 조건이다! 여러 조건들을 조합하면 O(n)보다 훨씬 좋은 시간복잡도를 가지는 알고리즘을 얻을 수 있다!












