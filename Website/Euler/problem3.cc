/*
 문제3. 큰수의 소인수분해를 해보고, 거기서 가장 큰 소인수를 찾아라!

 1. 일단 문제에서 하라는대로 풀어보자. 우선 소인수분해를 할 수 있는 알고리즘을 찾고, 소인수분해를 해본다.
 그렇게 얻은 소인수를 정렬하여 가장 큰 소인수를 답으로 제출하는 방법이 있다. 시간복잡도는 해당 알고리즘에 달려있다.

 2. 아무리 자연수n의 소인수가 커도, sqrt(n)보다는 반드시 같거나 작다는 성질을 이용하자.
 먼저 sqrt(n)을 구하고 floor(sqrt(n))을 초기값으로 잡고 초기값을 하나씩 줄여나가는 상태변수를 잡는다. 
 그리고 n을 그 상태변수로 나눠보고, n을 가장 먼저 나누어떨어뜨리는 그 수가 바로 가장 큰 소인수임을 활용한다.
 시간 복잡도는 sqrt(n)을 구하는 알고리즘과 O(n^(1/2))을 더해서 얻을 수 있다.

 2-1. sqrt(n)을 구하는 알고리즘은 SICP에 나와있는 뉴튼법을 응용한 알고리즘을 참고하여 만들거나 기본 라이브러리에 있는 sqrt()를 사용하라.
 2-2. 2-1을 활용해서 소수를 구하는 방법은 수없이 해보았으니 쉬울 것이다. 두 방법을 조합하면 첫번째 방법보다 시간복잡도를 개선할 수 있다.

 질문1 : 에라토스테네스의 체는 어떤가? -> 에라토스테네스의 체는 특정 범위에 있는 모든 소수들을 찾는 데 적합하지만, 3번 문제와 같이 가장큰 소인수 1개만 찾을 때에는 그렇게 적합하다고 보기 어렵다.

 질문2: 다른 좋은 알고리즘과 개념이 많은데(밀러-라빈, AKS, 페르마의 작은 정리, 카마이클 수, 등등...) 왜 사용하지 않았나?
 -> 아직 공부가 부족해서 그렇고, 항상 (n=3 부터 라던지...)앞에서만 적용할 수 있는 알고리즘인지도 잘 모르겠다. 나중에라도 한번 해보겠다.
 */
